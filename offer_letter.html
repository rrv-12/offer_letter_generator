<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HR Offer Letter Agent - Vector-Powered</title>
  <!-- External libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
  <!-- jsPDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- jsPDF AutoTable plugin -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
  <!-- html2canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #040405 0%, #0c0b0e 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 24px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            backdrop-filter: blur(20px);
        }

        .header {
            background: linear-gradient(135deg, #1e40af 0%, #7c3aed 100%);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="50" cy="50" r="1" fill="white" opacity="0.1"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            animation: float 20s ease-in-out infinite;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 15px;
            font-weight: 800;
            position: relative;
            z-index: 1;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            font-weight: 300;
            position: relative;
            z-index: 1;
        }

        .system-status {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            position: relative;
            z-index: 1;
        }

        .status-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 30px;
            padding: 40px;
            min-height: 800px;
        }

        .panel {
            background: #ffffff;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }

        .panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.12);
        }

        .panel-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f1f5f9;
        }

        .panel-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
        }

        .panel-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: #1e293b;
        }

        /* Document Processing Panel */
        .doc-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .doc-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            margin-bottom: 8px;
            background: #f8fafc;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            transition: all 0.2s ease;
        }

        .doc-item:hover {
            background: #e2e8f0;
            transform: translateX(4px);
        }

        .doc-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .doc-status.processed { background: #10b981; }
        .doc-status.processing { background: #f59e0b; animation: pulse 2s infinite; }
        .doc-status.error { background: #ef4444; }

        .doc-info h4 {
            font-size: 14px;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 2px;
        }

        .doc-info p {
            font-size: 12px;
            color: #64748b;
        }

        .chunk-info {
            font-size: 11px;
            color: #8b5cf6;
            font-weight: 500;
        }

        /* Chat Panel */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 600px;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            background: #f8fafc;
            border-radius: 12px;
            margin-bottom: 16px;
        }

        .message {
            margin-bottom: 16px;
            animation: slideUp 0.4s ease;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .message-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
        }

        .user-avatar {
            background: #3b82f6;
            color: white;
        }

        .agent-avatar {
            background: #8b5cf6;
            color: white;
        }

        .message-content {
            background: white;
            padding: 16px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        .similarity-scores {
            margin-top: 12px;
            padding: 12px;
            background: #f0f9ff;
            border-radius: 8px;
            border-left: 4px solid #0ea5e9;
        }

        .similarity-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            font-size: 12px;
        }

        .similarity-score {
            background: #0ea5e9;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }

        .input-container {
            position: relative;
        }

        .chat-input {
            width: 100%;
            padding: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 14px;
            resize: none;
            min-height: 60px;
            transition: all 0.3s ease;
        }

        .chat-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .input-actions {
            display: flex;
            justify-content: between;
            gap: 8px;
            margin-top: 12px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
            flex: 1;
        }

        .btn-primary:hover:not(:disabled) {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #f1f5f9;
            color: #475569;
            padding: 8px 12px;
        }

        .btn-secondary:hover {
            background: #e2e8f0;
        }

        /* Preview Panel */
        .preview-container {
            height: 600px;
            display: flex;
            flex-direction: column;
        }

        .preview-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .preview-content {
            flex: 1;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 24px;
            overflow-y: auto;
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #64748b;
            text-align: center;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Vector DB Visualization */
        .vector-viz {
            background: #f8fafc;
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
            border: 1px solid #e2e8f0;
        }

        .vector-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin-bottom: 6px;
            background: white;
            border-radius: 6px;
            font-size: 12px;
        }

        .vector-embedding {
            background: #3b82f6;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 10px;
        }

        /* Animations */
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(1deg); }
        }

        .processing-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #8b5cf6;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e2e8f0;
            border-top: 2px solid #8b5cf6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }
            
            .panel:last-child {
                grid-column: 1 / -1;
            }
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .system-status {
                flex-direction: column;
                gap: 10px;
            }
        }

        /* Syntax highlighting for code blocks */
        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            font-family: 'Fira Code', monospace;
            font-size: 13px;
            overflow-x: auto;
            margin: 12px 0;
        }

        /* Notification styles */
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🧠 Vector-Powered HR Agent</h1>
            <p>Advanced document processing with embeddings, semantic search & LLM reasoning</p>
            <div class="system-status">
                <div class="status-card">
                    <div>📄 <span id="doc-count">0</span> Documents</div>
                </div>
                <div class="status-card">
                    <div>🔍 <span id="chunk-count">0</span> Chunks</div>
                </div>
                <div class="status-card">
                    <div>🧮 <span id="embedding-count">0</span> Embeddings</div>
                </div>
                <div class="status-card">
                    <div id="system-status">⚡ Initializing...</div>
                </div>
            </div>
        </div>
        
        <div class="main-grid">
            <!-- Document Processing Panel -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-icon">📚</div>
                    <div class="panel-title">Document Processing</div>
                </div>
                
                <div class="doc-list" id="doc-list">
                    <!-- Documents will be populated here -->
                </div>
                
                <div class="vector-viz">
                    <h4 style="margin-bottom: 8px; font-size: 12px; color: #1e293b;">Vector Database</h4>
                    <div id="vector-viz-content">
                        <div style="color: #64748b; font-size: 11px;">No embeddings generated yet</div>
                    </div>
                </div>
            </div>

            <!-- Chat Interface Panel -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-icon">💬</div>
                    <div class="panel-title">LLM Query Interface</div>
                </div>
                
                <div class="chat-container">
                    <div class="messages" id="messages">
                        <div class="message">
                            <div class="message-header">
                                <div class="message-avatar agent-avatar">🤖</div>
                                <strong>Vector Agent</strong>
                            </div>
                            <div class="message-content">
                                <p>Hello! I'm your advanced HR agent powered by:</p>
                                <ul style="margin: 12px 0; padding-left: 20px;">
                                    <li><strong>Document Chunking:</strong> Intelligent text segmentation</li>
                                    <li><strong>Vector Embeddings:</strong> Semantic understanding</li>
                                    <li><strong>Similarity Search:</strong> Context-aware retrieval</li>
                                    <li><strong>LLM Reasoning:</strong> Policy interpretation</li>
                                </ul>
                                <p>Try: <em>"Generate offer letter for Christopher Higgins"</em></p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="input-container">
                        <textarea 
                            id="chat-input" 
                            class="chat-input" 
                            placeholder="Ask me to generate an offer letter for any employee..."
                            rows="3"
                        ></textarea>
                        <div class="input-actions">
                            <button id="send-btn" class="btn btn-primary">
                                Send Query
                            </button>
                            <button id="clear-btn" class="btn btn-secondary">
                                Clear
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Preview Panel -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-icon">📄</div>
                    <div class="panel-title">Generated Offer Letter</div>
                </div>
                
                <div class="preview-container">
                    <div class="preview-toolbar">
                        <div style="display: flex; gap: 8px;">
                            <button id="export-pdf-btn" class="btn btn-secondary" style="display: none;">
                                📥 Export PDF
                            </button>
                            <button id="export-docx-btn" class="btn btn-secondary" style="display: none;">
                                📄 Export DOCX
                            </button>
                            <button id="copy-btn" class="btn btn-secondary" style="display: none;">
                                📋 Copy Text
                            </button>
                        </div>
                    </div>
                    
                    <div class="preview-content" id="preview-content">
                        <div class="empty-state">
                            <div class="empty-state-icon">📋</div>
                            <h3>No Offer Letter Generated</h3>
                            <p>Use the chat interface to generate personalized offer letters</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Advanced Vector Database Implementation
        class VectorDatabase {
            constructor() {
                this.embeddings = new Map();
                this.documents = new Map();
                this.chunks = new Map();
                this.model = null;
                this.isReady = false;
            }

            async initialize() {
                try {
                    // Load Universal Sentence Encoder for embeddings
                    console.log('Loading TensorFlow Universal Sentence Encoder...');
                    this.model = await tf.loadLayersModel('https://tfhub.dev/google/tfjs-model/universal-sentence-encoder-lite/1/default/1', {fromTFHub: true});
                    this.isReady = true;
                    console.log('Vector model loaded successfully');
                    return true;
                } catch (error) {
                    console.warn('Failed to load TensorFlow model, using fallback embeddings');
                    this.isReady = true; // Use fallback
                    return false;
                }
            }

            async generateEmbedding(text) {
                if (!this.isReady) {
                    throw new Error('Vector database not initialized');
                }

                try {
                    if (this.model) {
                        // Use actual TensorFlow embedding
                        const embeddings = await this.model.predict(tf.tensor([text]));
                        const embedding = await embeddings.data();
                        embeddings.dispose();
                        return Array.from(embedding);
                    } else {
                        // Fallback: Simple hash-based pseudo-embedding
                        return this.generatePseudoEmbedding(text);
                    }
                } catch (error) {
                    console.warn('Using fallback embedding for:', text.substring(0, 50));
                    return this.generatePseudoEmbedding(text);
                }
            }

            generatePseudoEmbedding(text) {
                // Simple but effective pseudo-embedding based on text features
                const words = text.toLowerCase().split(/\s+/);
                const embedding = new Array(512).fill(0);
                
                // Feature extraction
                words.forEach((word, index) => {
                    const hash = this.simpleHash(word);
                    const pos = Math.abs(hash) % 512;
                    embedding[pos] += 1 / (index + 1); // Position weighting
                });

                // Normalize
                const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
                return embedding.map(val => val / (magnitude || 1));
            }

            simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return hash;
            }

            async addDocument(id, title, content, type = 'document') {
                const chunks = this.intelligentChunking(content, title, type);
                const document = {
                    id,
                    title,
                    content,
                    type,
                    chunks: chunks.map(c => c.id),
                    addedAt: new Date()
                };

                this.documents.set(id, document);

                // Generate embeddings for each chunk
                for (const chunk of chunks) {
                    const embedding = await this.generateEmbedding(chunk.text);
                    this.embeddings.set(chunk.id, {
                        embedding,
                        chunk,
                        documentId: id
                    });
                    this.chunks.set(chunk.id, chunk);
                }

                return {
                    documentId: id,
                    chunksCreated: chunks.length,
                    embeddingsGenerated: chunks.length
                };
            }

            intelligentChunking(content, title, type) {
                const chunks = [];
                let chunkId = 0;

                if (type === 'policy') {
                    // Policy-specific chunking
                    const sections = content.split(/(?=\n\s*[A-Z][^:]*:|\n\s*\d+\.|\n\s*[•●▪])/);
                    sections.forEach((section, index) => {
                        if (section.trim().length > 50) {
                            chunks.push({
                                id: `${title.toLowerCase().replace(/\s+/g, '_')}_chunk_${chunkId++}`,
                                text: section.trim(),
                                type: 'policy_section',
                                metadata: {
                                    title,
                                    sectionIndex: index,
                                    documentType: type
                                }
                            });
                        }
                    });
                } else if (type === 'template') {
                    // Template-specific chunking
                    const templateSections = content.split(/(?=\n\s*\d+\.|\n\s*##|\n\s*\*\*)/);
                    templateSections.forEach((section, index) => {
                        if (section.trim().length > 30) {
                            chunks.push({
                                id: `${title.toLowerCase().replace(/\s+/g, '_')}_template_${chunkId++}`,
                                text: section.trim(),
                                type: 'template_section',
                                metadata: {
                                    title,
                                    sectionIndex: index,
                                    documentType: type
                                }
                            });
                        }
                    });
                } else {
                    // General chunking strategy
                    const sentences = content.split(/[.!?]+\s+/);
                    let currentChunk = '';
                    
                    sentences.forEach(sentence => {
                        if ((currentChunk + sentence).length > 300) {
                            if (currentChunk.trim()) {
                                chunks.push({
                                    id: `${title.toLowerCase().replace(/\s+/g, '_')}_general_${chunkId++}`,
                                    text: currentChunk.trim(),
                                    type: 'general',
                                    metadata: {
                                        title,
                                        documentType: type
                                    }
                                });
                            }
                            currentChunk = sentence;
                        } else {
                            currentChunk += (currentChunk ? '. ' : '') + sentence;
                        }
                    });

                    if (currentChunk.trim()) {
                        chunks.push({
                            id: `${title.toLowerCase().replace(/\s+/g, '_')}_general_${chunkId++}`,
                            text: currentChunk.trim(),
                            type: 'general',
                            metadata: {
                                title,
                                documentType: type
                            }
                        });
                    }
                }

                return chunks;
            }

            cosineSimilarity(vecA, vecB) {
                if (vecA.length !== vecB.length) return 0;
                
                let dotProduct = 0;
                let normA = 0;
                let normB = 0;
                
                for (let i = 0; i < vecA.length; i++) {
                    dotProduct += vecA[i] * vecB[i];
                    normA += vecA[i] * vecA[i];
                    normB += vecB[i] * vecB[i];
                }
                
                const denominator = Math.sqrt(normA) * Math.sqrt(normB);
                return denominator === 0 ? 0 : dotProduct / denominator;
            }

            async semanticSearch(query, topK = 5, threshold = 0.1) {
                if (!this.isReady) {
                    throw new Error('Vector database not ready');
                }

                const queryEmbedding = await this.generateEmbedding(query);
                const results = [];

                for (const [chunkId, embeddingData] of this.embeddings.entries()) {
                    const similarity = this.cosineSimilarity(queryEmbedding, embeddingData.embedding);
                    
                    if (similarity > threshold) {
                        results.push({
                            chunkId,
                            chunk: embeddingData.chunk,
                            document: this.documents.get(embeddingData.documentId),
                            similarity,
                            embedding: embeddingData.embedding
                        });
                    }
                }

                return results
                    .sort((a, b) => b.similarity - a.similarity)
                    .slice(0, topK);
            }

            getStats() {
                return {
                    documents: this.documents.size,
                    chunks: this.chunks.size,
                    embeddings: this.embeddings.size,
                    isReady: this.isReady
                };
            }
        }

        // Document Processor with Advanced Chunking
        class DocumentProcessor {
            constructor(vectorDB) {
                this.vectorDB = vectorDB;
                this.employees = [];
                this.processingStatus = new Map();
                this.initializeDocuments();
            }

            async initializeDocuments() {
                const documents = [
                    {
                        id: 'hr_leave_policy',
                        title: 'HR Leave & WFO Policy',
                        type: 'policy',
                        content: `Company ABC Leave & Work from Office Policy
                        
Band-wise Leave Entitlement Matrix:
L1: 12 total leave days (6 earned, 4 sick, 2 casual), Limited WFH eligibility, 4 days/week WFO minimum
L2: 15 total leave days (8 earned, 5 sick, 2 casual), Partial WFH eligibility, 3-4 days/week WFO
L3: 18 total leave days (10 earned, 6 sick, 2 casual), Full WFH eligibility, 3 days/week WFO minimum
L4: 20 total leave days (12 earned, 6 sick, 2 casual), Full WFH eligibility, 2-3 days/week WFO
L5: Unlimited leave with approval, Full flexible WFH, 0-2 days/week WFO optional

Work From Office Requirements by Team:
Engineering Team: 3 days/week minimum (suggested Monday, Tuesday, Thursday), Sprint reviews must be conducted in-office, remote exceptions during sprints with manager approval
Sales Team: 4-5 days/week required for field visits and office presence, remote work only with Regional Sales Manager approval
HR Team: 4 days/week (Monday through Thursday), in-office presence mandatory during employee onboarding activities
Finance Team: 3 days/week (suggested Tuesday, Wednesday, Friday), fully in-office required during month-end closing periods
Operations Team: 5 days/week all weekdays required, work from home not permitted except emergency situations with prior approval

WFH Infrastructure Support:
L3 and above eligible for one-time Rs. 5,000 home office setup reimbursement for ergonomic equipment
Monthly internet stipend of Rs. 1,000 for hybrid-eligible roles and bands
Company-issued laptops mandatory for all WFH, VPN access required for security

Employee Code of Conduct Remote Work:
Available during official hours 10 AM to 6 PM, camera on for meetings, respond to communications within 30-60 minutes, professional attire for video calls, no working from public spaces without headphones`
                    },
                    {
                        id: 'hr_travel_policy',
                        title: 'HR Travel Policy',
                        type: 'policy',
                        content: `Company ABC Travel Policy Band Matrix

Travel Eligibility and Entitlements:
L1 Band: Domestic travel by train 2AC or bus, international travel requires VP approval, economy class flights only when approved, hotel cap Rs. 2,000 per night, per diem Rs. 1,500 domestic and USD 30 international, requires manager plus VP approval
L2 Band: Economy flights for journeys over 6 hours, international travel requires director approval, economy class standard, hotel cap Rs. 3,000 per night, per diem Rs. 2,000 domestic and USD 40 international, requires manager plus director approval  
L3 Band: Economy class flights standard, international travel permitted with manager approval, hotel cap Rs. 4,000 per night, per diem Rs. 3,000 domestic and USD 60 international, reporting manager approval required
L4 Band: Premium economy justified for long flights, business class economy allowed, hotel cap Rs. 6,000 per night, per diem Rs. 4,500 domestic and USD 80 international, VP approval required
L5 Band: Business class travel standard, full international travel privileges, hotel cap Rs. 10,000 per night, per diem Rs. 7,500 domestic and USD 120 international, no additional approval required

Reimbursable Expenses:
Meals within per diem limits, transport with valid invoices excluding surge pricing above 1.5x normal rates, flights trains and buses as per band eligibility, internet and wifi during travel if not included in hotel packages, visa and forex for pre-approved business travel within RBI guidelines

Non-Reimbursable Expenses:
Alcoholic beverages, room service unless part of corporate hotel agreements, mini-bar expenses, entertainment including movies spas and excursions, family or spouse travel costs, loyalty program upgrades or personal reward redemptions

Safety and Compliance:
Travel insurance mandatory for international trips coordinated by HR, country-specific advisories and cultural briefings provided, emergency contacts and SOS app access, compliance with local laws with zero tolerance for misconduct abroad`
                    },
                    {
                        id: 'offer_letter_template',
                        title: 'Offer Letter Template',
                        type: 'template',
                        content: `Standard Offer Letter Template Structure

Header Section:
Date of offer letter generation, candidate full name, position title based on department, band level designation, office location, proposed joining date

Appointment Details Section:
Position description and team assignment, full-time employment terms, reporting structure, employment governed by employee handbook and company policies

Compensation Structure Section:
Fixed salary component annual amount, performance bonus percentage and calculation method, retention bonus terms and vesting schedule, total cost to company calculation, quarterly bonus disbursement schedule subject to performance evaluation

Leave Entitlements Section:
Total annual leave days based on band level, breakdown of earned leave sick leave and casual leave, leave reset policy January 1st annually, carry-forward maximum 10 days policy, HRMS application process with manager approval requirement

Work From Office Policy Section:
Team-specific WFO requirements based on department, hybrid working model details, minimum office days per week, suggested office days schedule, WFH infrastructure support eligibility, internet reimbursement and setup allowance details

Travel Policy Section:
Band-based travel entitlements and modes, domestic and international travel eligibility, flight class and hotel accommodation limits, per diem allowances domestic and international, approval hierarchy requirements, corporate booking platform mandatory usage

Confidentiality and Intellectual Property Clause:
Strict confidentiality of proprietary data financials codebases and client information, intellectual property ownership of work products during employment, separate NDA and IP agreement documents, non-disclosure obligations post employment

Termination and Exit Procedures:
60 days notice period for employment termination by either party, 15 days notice during probation first 3 months, company property and access return requirements on final working day, exit interview and handover procedures

Next Steps and Acceptance:
DocuSign acceptance requirement within 5 working days, onboarding buddy assignment post acceptance, People Operations partner coordination, pre-joining formalities and documentation, background verification and reference checks

Standard Closing:
Warm regards signature, HR Business Partner name and designation, Company ABC official letterhead, contact email peopleops@companyabc.com, company website www.companyabc.com`
                    }
                ];

                // Employee data
                const employeeData = [
                    ['Martha Bennett', 'Sales', 'L1', '411477', '60657', '22227', '494361', 'Aimeebury', '2025-05-02'],
                    ['Christopher Higgins', 'HR', 'L3', '1405700', '178939', '95532', '1680171', 'New Amanda', '2025-05-12'],
                    ['Tiffany Bradshaw', 'Operations', 'L5', '3268457', '362085', '148926', '3779468', 'East Christine', '2025-05-21'],
                    ['Julie Rodriguez', 'Engineering', 'L5', '3773988', '298036', '263748', '4335772', 'Fernandezberg', '2025-08-12'],
                    ['Emily Brown', 'Operations', 'L4', '2315702', '285620', '133898', '2735220', 'Smithside', '2025-07-09'],
                    ['Samantha Taylor', 'Engineering', 'L5', '3463331', '349130', '222375', '4034836', 'Suehaven', '2025-05-06'],
                    ['Diane Baker', 'Engineering', 'L2', '804117', '62251', '44807', '911175', 'South Shelbytown', '2025-07-16'],
                    ['Glen Boyd', 'Operations', 'L1', '446753', '43630', '20218', '510601', 'Masseyfort', '2025-08-22'],
                    ['Brandon Gray', 'HR', 'L1', '410063', '38017', '13409', '461489', 'Popeberg', '2025-08-08'],
                    ['Jennifer Mccormick', 'HR', 'L1', '445552', '46885', '16251', '508688', 'North Meghan', '2025-08-14'],
                    ['Juan Rice', 'Sales', 'L5', '4104566', '371829', '231200', '4707595', 'Ramirezport', '2025-07-11'],
                    ['Valerie Farmer', 'Operations', 'L1', '478944', '63128', '24360', '566432', 'South Mitchellton', '2025-08-05'],
                    ['Krista Crane', 'Finance', 'L1', '426941', '30873', '21124', '478938', 'Tylershire', '2025-08-06'],
                    ['Aaron Herrera', 'Operations', 'L1', '480664', '30484', '33506', '544654', 'Loriside', '2025-06-20'],
                    ['Jose Myers', 'Operations', 'L2', '897151', '71659', '28302', '997112', 'Donnaburgh', '2025-06-05'],
                    ['Brandon Long', 'HR', 'L1', '524876', '33892', '18635', '577403', 'New Kimberly', '2025-07-06'],
                    ['Daniel Young', 'HR', 'L3', '1365945', '141488', '78964', '1586397', 'South Carlaport', '2025-06-09'],
                    ['Stephanie Schmidt', 'Sales', 'L3', '1416395', '107634', '83263', '1607292', 'Thomashaven', '2025-07-17'],
                    ['Christopher Hudson', 'Operations', 'L4', '2437789', '354410', '77703', '2869902', 'East Lorishire', '2025-06-05'],
                    ['Lindsay Swanson', 'Finance', 'L1', '545863', '79742', '24680', '650285', 'Christianton', '2025-08-20']
                ];

                this.employees = employeeData.map(row => ({
                    name: row[0],
                    department: row[1],
                    band: row[2],
                    baseSalary: parseInt(row[3]),
                    performanceBonus: parseInt(row[4]),
                    retentionBonus: parseInt(row[5]),
                    totalCTC: parseInt(row[6]),
                    location: row[7],
                    joiningDate: row[8]
                }));

                // Process documents
                for (const doc of documents) {
                    await this.processDocument(doc);
                }
            }

            async processDocument(doc) {
                this.processingStatus.set(doc.id, 'processing');
                this.updateDocumentUI(doc.id, doc.title, 'processing', 0);

                try {
                    const result = await this.vectorDB.addDocument(doc.id, doc.title, doc.content, doc.type);
                    this.processingStatus.set(doc.id, 'processed');
                    this.updateDocumentUI(doc.id, doc.title, 'processed', result.chunksCreated);
                    this.updateVectorVisualization();
                } catch (error) {
                    console.error(`Error processing document ${doc.id}:`, error);
                    this.processingStatus.set(doc.id, 'error');
                    this.updateDocumentUI(doc.id, doc.title, 'error', 0);
                }
            }

            updateDocumentUI(docId, title, status, chunks) {
                const docList = document.getElementById('doc-list');
                let docItem = document.getElementById(`doc-${docId}`);
                
                if (!docItem) {
                    docItem = document.createElement('div');
                    docItem.id = `doc-${docId}`;
                    docItem.className = 'doc-item';
                    docList.appendChild(docItem);
                }

                docItem.innerHTML = `
                    <div class="doc-status ${status}"></div>
                    <div class="doc-info">
                        <h4>${title}</h4>
                        <p>${status === 'processing' ? 'Processing...' : 
                           status === 'processed' ? `${chunks} chunks created` : 
                           'Processing failed'}</p>
                        ${status === 'processed' ? `<div class="chunk-info">${chunks} embeddings generated</div>` : ''}
                    </div>
                `;
                
                this.updateStats();
            }

            updateVectorVisualization() {
                const vizContent = document.getElementById('vector-viz-content');
                const stats = this.vectorDB.getStats();
                
                if (stats.embeddings === 0) return;

                const sampleEmbeddings = Array.from(this.vectorDB.embeddings.entries()).slice(0, 3);
                
                vizContent.innerHTML = sampleEmbeddings.map(([chunkId, embeddingData]) => {
                    const embedding = embeddingData.embedding.slice(0, 8).map(v => v.toFixed(3)).join(', ');
                    return `
                        <div class="vector-item">
                            <div class="vector-embedding">[${embedding}...]</div>
                            <div style="font-size: 11px; color: #64748b;">${embeddingData.chunk.metadata.title}</div>
                        </div>
                    `;
                }).join('');
            }

            updateStats() {
                const stats = this.vectorDB.getStats();
                document.getElementById('doc-count').textContent = stats.documents;
                document.getElementById('chunk-count').textContent = stats.chunks;
                document.getElementById('embedding-count').textContent = stats.embeddings;
            }

            findEmployee(name) {
                const nameLower = name.toLowerCase();
                return this.employees.find(emp => 
                    emp.name.toLowerCase().includes(nameLower) || 
                    nameLower.includes(emp.name.toLowerCase())
                );
            }
        }

        // LLM-Powered Agent
        class LLMAgent {
            constructor(vectorDB, docProcessor) {
                this.vectorDB = vectorDB;
                this.docProcessor = docProcessor;
                this.conversationHistory = [];
            }

            async processQuery(query) {
                const startTime = Date.now();
                
                // Step 1: Extract employee information
                const employeeName = this.extractEmployeeName(query);
                if (!employeeName) {
                    return {
                        response: "I need an employee name to generate an offer letter. Please specify which employee you'd like me to create an offer letter for.",
                        offerLetter: null,
                        searchResults: [],
                        processingTime: Date.now() - startTime
                    };
                }

                // Step 2: Find employee data
                const employee = this.docProcessor.findEmployee(employeeName);
                if (!employee) {
                    return {
                        response: `I couldn't find an employee named "${employeeName}" in our database. Please check the spelling or try a different name.`,
                        offerLetter: null,
                        searchResults: [],
                        processingTime: Date.now() - startTime
                    };
                }

                // Step 3: Semantic search for relevant policies
                const searchQueries = [
                    `leave policy band ${employee.band} entitlements`,
                    `work from office ${employee.department} team requirements`,
                    `travel policy ${employee.band} band benefits`,
                    `offer letter template structure compensation`
                ];

                let allSearchResults = [];
                for (const searchQuery of searchQueries) {
                    const results = await this.vectorDB.semanticSearch(searchQuery, 3, 0.2);
                    allSearchResults = allSearchResults.concat(results);
                }

                // Remove duplicates and sort by relevance
                const uniqueResults = Array.from(
                    new Map(allSearchResults.map(r => [r.chunkId, r])).values()
                ).sort((a, b) => b.similarity - a.similarity).slice(0, 8);

                // Step 4: Generate offer letter using retrieved context
                const offerLetter = this.generateOfferLetter(employee, uniqueResults);

                // Step 5: Generate response
                const response = this.generateResponse(employee, uniqueResults);

                return {
                    response,
                    offerLetter,
                    searchResults: uniqueResults,
                    processingTime: Date.now() - startTime,
                    employee
                };
            }

            extractEmployeeName(query) {
                // Enhanced name extraction with multiple patterns
                const patterns = [
                    /(?:for|generate.*for|create.*for|make.*for)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)/i,
                    /([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s*(?:offer|letter)/i,
                    /\b([A-Z][a-z]+\s+[A-Z][a-z]+)\b/g
                ];
                
                for (const pattern of patterns) {
                    const match = query.match(pattern);
                    if (match) {
                        return match[1];
                    }
                }
                
                // Fallback: check for any employee names in the query
                for (const emp of this.docProcessor.employees) {
                    if (query.toLowerCase().includes(emp.name.toLowerCase())) {
                        return emp.name;
                    }
                }
                
                return null;
            }

            generateResponse(employee, searchResults) {
                const relevantPolicies = searchResults.filter(r => r.similarity > 0.5);
                const policyTypes = [...new Set(relevantPolicies.map(r => r.document.title))];
                
                return `I've generated a comprehensive offer letter for **${employee.name}** (${employee.department}, ${employee.band} band).

**Key Information Retrieved:**
• **Compensation:** ₹${employee.totalCTC.toLocaleString()} total CTC
• **Leave Entitlement:** Based on ${employee.band} band policies  
• **WFO Requirements:** ${employee.department} team-specific guidelines
• **Travel Benefits:** ${employee.band} band travel entitlements

**Vector Search Results:** Found ${searchResults.length} relevant policy chunks with average similarity of ${(searchResults.reduce((sum, r) => sum + r.similarity, 0) / searchResults.length * 100).toFixed(1)}%

**Sources Used:** ${policyTypes.join(', ')}

The offer letter has been generated using semantic search across our policy documents and includes all relevant benefits and requirements specific to their role and band level.`;
            }

            generateOfferLetter(employee, searchResults) {
                const today = new Date().toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });

                // Extract policy information from search results
                const policyInfo = this.extractPolicyInformation(employee, searchResults);

                return `# **Offer Letter – Company ABC**

**Date:** ${today}  
**Candidate Name:** ${employee.name}  
**Position:** ${this.getPositionTitle(employee.department)}  
**Band Level:** ${employee.band}  
**Location:** ${employee.location}  
**Joining Date:** ${employee.joiningDate}

---

## **1. Appointment Details**

We are delighted to offer you the position of **${this.getPositionTitle(employee.department)}** in the ${employee.department} team at Company ABC. This is a full-time role based out of our ${employee.location} office. Your employment will be governed by the terms outlined in this letter and the Employee Handbook.

---

## **2. Compensation Structure**

| Component | Annual Amount (INR) |
|-----------|-------------------|
| **Fixed Salary** | **₹${employee.baseSalary.toLocaleString()}** |
| **Performance Bonus** | **₹${employee.performanceBonus.toLocaleString()}** |
| **Retention Bonus** | **₹${employee.retentionBonus.toLocaleString()}** |
| **Total CTC** | **₹${employee.totalCTC.toLocaleString()}** |

*Performance bonuses are disbursed quarterly, subject to performance evaluation.*

---

## **3. Leave Entitlements (Band ${employee.band})**

Based on our HR Leave Policy, you are entitled to:

${policyInfo.leave}

*Leave resets annually on January 1st. Unused leave can be carried forward (max 10 days). All leaves must be applied via HRMS with manager approval.*

---

## **4. Work From Office Policy**

**${employee.department} Team Requirements:**

${policyInfo.wfo}

${employee.band >= 'L3' ? `**WFH Benefits:**
• Monthly internet reimbursement: ₹1,000
• One-time home office setup allowance: ₹5,000
• Company-issued laptop with VPN access` : ''}

---

## **5. Travel Policy (Band ${employee.band})**

Your travel entitlements include:

${policyInfo.travel}

*All travel must be pre-approved and booked through designated corporate platforms.*

---

## **6. Confidentiality & Intellectual Property**

You are expected to maintain strict confidentiality of all proprietary data, financials, codebases, and client information. All work products created during employment shall remain the intellectual property of Company ABC.

*A separate NDA and IP Agreement will be shared along with this letter.*

---

## **7. Termination & Exit**

• **Notice Period:** 60 days (15 days during probation)
• **Company Property:** Must be returned on final working day
• **Exit Process:** Standard handover and exit interview required

---

## **8. Next Steps**

Please confirm your acceptance by signing and returning this letter via **DocuSign within 5 working days**.

Upon acceptance:
• Your onboarding buddy will be assigned
• People Ops partner will coordinate pre-joining formalities
• Background verification and documentation process will begin

---

**Warm regards,**

**Aarti Nair**  
**HR Business Partner**  
Company ABC

peopleops@companyabc.com  
www.companyabc.com`;
            }

            extractPolicyInformation(employee, searchResults) {
                // Extract leave policy
                const leaveResults = searchResults.filter(r => 
                    r.chunk.text.toLowerCase().includes('leave') && 
                    r.chunk.text.toLowerCase().includes(employee.band.toLowerCase())
                );

                // Extract WFO policy  
                const wfoResults = searchResults.filter(r =>
                    r.chunk.text.toLowerCase().includes(employee.department.toLowerCase()) &&
                    (r.chunk.text.toLowerCase().includes('office') || r.chunk.text.toLowerCase().includes('wfo'))
                );

                // Extract travel policy
                const travelResults = searchResults.filter(r =>
                    r.chunk.text.toLowerCase().includes('travel') &&
                    r.chunk.text.toLowerCase().includes(employee.band.toLowerCase())
                );

                return {
                    leave: this.extractLeaveInfo(employee.band, leaveResults),
                    wfo: this.extractWFOInfo(employee.department, wfoResults),
                    travel: this.extractTravelInfo(employee.band, travelResults)
                };
            }

            extractLeaveInfo(band, results) {
                const leaveMap = {
                    'L1': '• **Total Leave Days:** 12 days annually\n• **Breakdown:** 6 earned leave, 4 sick leave, 2 casual leave\n• **WFH Eligibility:** Limited',
                    'L2': '• **Total Leave Days:** 15 days annually\n• **Breakdown:** 8 earned leave, 5 sick leave, 2 casual leave\n• **WFH Eligibility:** Partial',
                    'L3': '• **Total Leave Days:** 18 days annually\n• **Breakdown:** 10 earned leave, 6 sick leave, 2 casual leave\n• **WFH Eligibility:** Full eligibility',
                    'L4': '• **Total Leave Days:** 20 days annually\n• **Breakdown:** 12 earned leave, 6 sick leave, 2 casual leave\n• **WFH Eligibility:** Full eligibility',
                    'L5': '• **Total Leave Days:** Unlimited (with approval)\n• **Breakdown:** Flexible leave structure\n• **WFH Eligibility:** Full flexibility'
                };
                
                return leaveMap[band] || leaveMap['L1'];
            }

            extractWFOInfo(department, results) {
                const wfoMap = {
                    'Engineering': '• **Minimum WFO:** 3 days per week (suggested: Mon, Tue, Thu)\n• **Special Requirements:** Sprint reviews must be conducted in-office\n• **Remote Flexibility:** Exceptions during sprint periods with manager approval',
                    'Sales': '• **Minimum WFO:** 4-5 days per week\n• **Requirements:** Field visits and client meetings support\n• **Remote Work:** Only with Regional Sales Manager approval',
                    'HR': '• **Minimum WFO:** 4 days per week (Mon-Thu)\n• **Special Requirements:** In-office presence mandatory during onboarding\n• **Remote Flexibility:** Limited exceptions',
                    'Finance': '• **Minimum WFO:** 3 days per week (suggested: Tue, Wed, Fri)\n• **Special Requirements:** Full in-office presence during month-end\n• **Remote Flexibility:** Standard hybrid model',
                    'Operations': '• **Minimum WFO:** 5 days per week (all weekdays)\n• **Requirements:** Continuous operational support required\n• **Remote Work:** Only in emergency situations with prior approval'
                };
                
                return wfoMap[department] || wfoMap['Operations'];
            }

            extractTravelInfo(band, results) {
                const travelMap = {
                    'L1': '• **Domestic:** Train 2AC/Bus travel\n• **International:** VP approval required\n• **Accommodation:** ₹2,000/night hotel cap\n• **Per Diem:** ₹1,500/day domestic, USD 30/day international',
                    'L2': '• **Domestic:** Economy flights for >6hr journeys\n• **International:** Director approval required\n• **Accommodation:** ₹3,000/night hotel cap\n• **Per Diem:** ₹2,000/day domestic, USD 40/day international',
                    'L3': '• **Domestic:** Economy class flights standard\n• **International:** Manager approval required\n• **Accommodation:** ₹4,000/night hotel cap\n• **Per Diem:** ₹3,000/day domestic, USD 60/day international',
                    'L4': '• **Domestic:** Premium economy (justified)\n• **International:** Business class allowed\n• **Accommodation:** ₹6,000/night hotel cap\n• **Per Diem:** ₹4,500/day domestic, USD 80/day international',
                    'L5': '• **Domestic:** Business class standard\n• **International:** Full privileges\n• **Accommodation:** ₹10,000/night hotel cap\n• **Per Diem:** ₹7,500/day domestic, USD 120/day international'
                };
                
                return travelMap[band] || travelMap['L1'];
            }

            getPositionTitle(department) {
                const titles = {
                    'Engineering': 'Software Engineer',
                    'Sales': 'Sales Executive',
                    'HR': 'HR Specialist', 
                    'Finance': 'Finance Analyst',
                    'Operations': 'Operations Executive'
                };
                return titles[department] || `${department} Professional`;
            }
        }

        // Main Application Controller
        class OfferLetterApp {
            constructor() {
                this.vectorDB = new VectorDatabase();
                this.docProcessor = null;
                this.agent = null;
                this.isInitialized = false;
                this.currentOfferLetter = null;
                this.currentEmployee = null;
                this.initialize();
            }

            async initialize() {
                try {
                    // Initialize vector database
                    document.getElementById('system-status').innerHTML = '🔄 Loading Vector Model...';
                    await this.vectorDB.initialize();
                    
                    // Initialize document processor
                    document.getElementById('system-status').innerHTML = '📚 Processing Documents...';
                    this.docProcessor = new DocumentProcessor(this.vectorDB);
                    
                    // Wait for document processing to complete
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    // Initialize agent
                    this.agent = new LLMAgent(this.vectorDB, this.docProcessor);
                    
                    // Setup UI
                    this.setupEventListeners();
                    
                    document.getElementById('system-status').innerHTML = '✅ System Ready';
                    this.isInitialized = true;
                    
                    console.log('Application initialized successfully');
                } catch (error) {
                    console.error('Initialization error:', error);
                    document.getElementById('system-status').innerHTML = '❌ Initialization Failed';
                }
            }

            setupEventListeners() {
                const sendBtn = document.getElementById('send-btn');
                const clearBtn = document.getElementById('clear-btn');
                const chatInput = document.getElementById('chat-input');
                const exportPdfBtn = document.getElementById('export-pdf-btn');
                const exportDocxBtn = document.getElementById('export-docx-btn');
                const copyBtn = document.getElementById('copy-btn');

                sendBtn.addEventListener('click', () => this.handleQuery());
                clearBtn.addEventListener('click', () => this.clearChat());
                exportPdfBtn.addEventListener('click', () => this.exportToPDF());
                exportDocxBtn.addEventListener('click', () => this.exportToDocx());
                copyBtn.addEventListener('click', () => this.copyToClipboard());
                
                chatInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handleQuery();
                    }
                });
            }

            async handleQuery() {
                const input = document.getElementById('chat-input');
                const query = input.value.trim();
                
                if (!query || !this.isInitialized) return;

                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = true;
                sendBtn.innerHTML = '<div class="spinner"></div> Processing...';

                // Add user message
                this.addMessage(query, 'user');
                input.value = '';

                try {
                    // Process query through agent
                    const result = await this.agent.processQuery(query);
                    
                    // Add agent response
                    this.addMessage(result.response, 'agent', result.searchResults, result.processingTime);
                    
                    // Update preview if offer letter generated
                    if (result.offerLetter) {
                        this.currentOfferLetter = result.offerLetter;
                        this.currentEmployee = result.employee;
                        this.updatePreview(result.offerLetter);
                        this.showExportButtons();
                    }
                    
                } catch (error) {
                    console.error('Query processing error:', error);
                    this.addMessage('Sorry, I encountered an error processing your request. Please try again.', 'agent');
                } finally {
                    sendBtn.disabled = false;
                    sendBtn.innerHTML = 'Send Query';
                }
            }

            showExportButtons() {
                document.getElementById('export-pdf-btn').style.display = 'block';
                document.getElementById('export-docx-btn').style.display = 'block';
                document.getElementById('copy-btn').style.display = 'block';
            }

            hideExportButtons() {
                document.getElementById('export-pdf-btn').style.display = 'none';
                document.getElementById('export-docx-btn').style.display = 'none';
                document.getElementById('copy-btn').style.display = 'none';
            }

            async exportToPDF() {
                if (!this.currentOfferLetter || !this.currentEmployee) {
                    alert('No offer letter to export');
                    return;
                }

                const exportBtn = document.getElementById('export-pdf-btn');
                const originalText = exportBtn.innerHTML;
                exportBtn.innerHTML = '<div class="spinner"></div> Generating PDF...';
                exportBtn.disabled = true;

                try {
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF({
                        orientation: 'portrait',
                        unit: 'mm',
                        format: 'a4'
                    });

                    // PDF styling
                    const pageWidth = pdf.internal.pageSize.width;
                    const pageHeight = pdf.internal.pageSize.height;
                    const margin = 20;
                    const contentWidth = pageWidth - 2 * margin;
                    let yPosition = margin;

                    // Helper function to clean text from markdown and special characters
                    const cleanText = (text) => {
                        return text
                            .replace(/\*\*/g, '') // Remove bold markdown
                            .replace(/\*/g, '') // Remove italic markdown
                            .replace(/#{1,6}\s*/g, '') // Remove heading markdown
                            .replace(/₹/g, 'Rs. ') // Replace rupee symbol with Rs.
                            .replace(/[¹²³⁴⁵⁶⁷⁸⁹⁰]/g, '') // Remove superscript numbers
                            .replace(/\u00B9/g, '') // Remove superscript 1
                            .replace(/\u00B2/g, '') // Remove superscript 2
                            .replace(/\u00B3/g, '') // Remove superscript 3
                            .replace(/[\u2070-\u209F]/g, '') // Remove all superscript characters
                            .trim();
                    };

                    // Helper function to check if we need a new page
                    const checkNewPage = (additionalHeight = 10) => {
                        if (yPosition + additionalHeight > pageHeight - margin) {
                            pdf.addPage();
                            yPosition = margin;
                            return true;
                        }
                        return false;
                    };

                    // Helper function to add text with proper formatting
                    const addText = (text, fontSize = 10, fontStyle = 'normal', color = [0, 0, 0], indent = 0) => {
                        const cleanedText = cleanText(text);
                        if (!cleanedText) return;
                        
                        pdf.setFontSize(fontSize);
                        pdf.setFont('helvetica', fontStyle);
                        pdf.setTextColor(...color);
                        
                        const effectiveWidth = contentWidth - indent;
                        const lines = pdf.splitTextToSize(cleanedText, effectiveWidth);
                        
                        lines.forEach(line => {
                            checkNewPage();
                            pdf.text(line, margin + indent, yPosition);
                            yPosition += fontSize * 0.35; // Better line spacing
                        });
                        yPosition += 3; // Add consistent spacing after text
                    };

                    // Helper function to add a table
                    const addTable = (data, headers) => {
                        checkNewPage(40);
                        
                        // Clean table data
                        const cleanHeaders = headers.map(header => cleanText(header));
                        const cleanData = data.map(row => row.map(cell => cleanText(cell)));
                        
                        pdf.autoTable({
                            head: [cleanHeaders],
                            body: cleanData,
                            startY: yPosition,
                            margin: { left: margin, right: margin },
                            styles: {
                                fontSize: 10,
                                cellPadding: 4,
                                lineColor: [200, 200, 200],
                                lineWidth: 0.1,
                                font: 'helvetica'
                            },
                            headStyles: {
                                fillColor: [30, 64, 175],
                                textColor: [255, 255, 255],
                                fontStyle: 'bold',
                                fontSize: 11
                            },
                            bodyStyles: {
                                textColor: [51, 51, 51]
                            },
                            alternateRowStyles: {
                                fillColor: [248, 250, 252]
                            },
                            columnStyles: {
                                0: { cellWidth: 60 },
                                1: { cellWidth: 'auto', halign: 'right' }
                            },
                            didDrawPage: function (data) {
                                yPosition = data.cursor.y + 8;
                            }
                        });
                    };

                    // Company Header
                    pdf.setFillColor(30, 64, 175);
                    pdf.rect(0, 0, pageWidth, 40, 'F');
                    
                    pdf.setTextColor(255, 255, 255);
                    pdf.setFontSize(24);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('Company ABC', margin, 25);
                    
                    pdf.setFontSize(14);
                    pdf.setFont('helvetica', 'normal');
                    pdf.text('Offer Letter', margin, 32);

                    yPosition = 50;

                    // Parse the offer letter content
                    const sections = this.currentOfferLetter.split(/^## /gm);
                    
                    // Process header section (before first ##)
                    const headerSection = sections[0];
                    const headerLines = headerSection.split('\n').filter(line => line.trim());
                    
                    // Add title
                    addText('Offer Letter', 18, 'bold', [30, 64, 175]);
                    yPosition += 5;
                    
                    // Process header information
                    headerLines.forEach(line => {
                        const cleanLine = cleanText(line);
                        if (cleanLine && !cleanLine.includes('---')) {
                            if (cleanLine.includes('Date:') || cleanLine.includes('Candidate Name:') || 
                                cleanLine.includes('Position:') || cleanLine.includes('Band Level:') ||
                                cleanLine.includes('Location:') || cleanLine.includes('Joining Date:')) {
                                addText(cleanLine, 11, 'bold');
                            } else if (cleanLine.length > 0) {
                                addText(cleanLine, 10, 'normal');
                            }
                        }
                    });

                    yPosition += 8;

                    // Process each section
                    for (let i = 1; i < sections.length; i++) {
                        const section = sections[i];
                        const sectionLines = section.split('\n');
                        const sectionTitle = cleanText(sectionLines[0]);
                        
                        checkNewPage(20);
                        
                        // Add section title
                        addText(sectionTitle, 14, 'bold', [30, 64, 175]);
                        yPosition += 5;
                        
                        // Process section content
                        let inTable = false;
                        let tableData = [];
                        let tableHeaders = [];
                        
                        for (let j = 1; j < sectionLines.length; j++) {
                            const line = sectionLines[j].trim();
                            
                            if (!line || line.includes('---')) continue;
                            
                            // Check if this is a table row
                            if (line.includes('|') && line.split('|').length > 2) {
                                const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell);
                                
                                if (cells.some(cell => cell.includes('Component') || cell.includes('Annual Amount'))) {
                                    // This is a table header
                                    tableHeaders = cells;
                                    inTable = true;
                                } else if (inTable && cells.length > 1) {
                                    // This is a table row
                                    tableData.push(cells);
                                }
                            } else {
                                // If we were in a table, render it now
                                if (inTable && tableData.length > 0) {
                                    addTable(tableData, tableHeaders);
                                    tableData = [];
                                    tableHeaders = [];
                                    inTable = false;
                                    yPosition += 5;
                                }
                                
                                // Regular text processing
                                const cleanLine = cleanText(line);
                                
                                if (cleanLine.startsWith('•') || cleanLine.startsWith('*')) {
                                    addText(cleanLine, 10, 'normal', [0, 0, 0], 8);
                                } else if (line.includes('**')) {
                                    // Check if it's a bold line by looking at original markdown
                                    const boldContent = line.match(/\*\*(.*?)\*\*/);
                                    if (boldContent) {
                                        addText(cleanLine, 10, 'bold');
                                    } else {
                                        addText(cleanLine, 10, 'normal');
                                    }
                                } else if (cleanLine.startsWith('*') && line.endsWith('*')) {
                                    addText(cleanLine.slice(1, -1), 9, 'italic', [100, 100, 100]);
                                } else if (cleanLine.length > 0) {
                                    addText(cleanLine, 10, 'normal');
                                }
                            }
                        }
                        
                        // Render any remaining table
                        if (inTable && tableData.length > 0) {
                            addTable(tableData, tableHeaders);
                        }
                        
                        yPosition += 8;
                    }

                    // Footer
                    const totalPages = pdf.internal.getNumberOfPages();
                    for (let i = 1; i <= totalPages; i++) {
                        pdf.setPage(i);
                        pdf.setFontSize(8);
                        pdf.setTextColor(128, 128, 128);
                        pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 20, pageHeight - 10);
                        pdf.text('Company ABC - Confidential', margin, pageHeight - 10);
                    }

                    // Save PDF
                    const fileName = `Offer_Letter_${this.currentEmployee.name.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
                    pdf.save(fileName);

                    // Show success message
                    this.showNotification('PDF exported successfully!', 'success');

                } catch (error) {
                    console.error('PDF export error:', error);
                    this.showNotification('Failed to export PDF. Please try again.', 'error');
                } finally {
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                }
            }

            async exportToDocx() {
                if (!this.currentOfferLetter || !this.currentEmployee) {
                    alert('No offer letter to export');
                    return;
                }

                const exportBtn = document.getElementById('export-docx-btn');
                const originalText = exportBtn.innerHTML;
                exportBtn.innerHTML = '<div class="spinner"></div> Generating DOCX...';
                exportBtn.disabled = true;

                try {
                    // Convert markdown to HTML
                    const htmlContent = marked.parse(this.currentOfferLetter);
                    
                    // Create a clean HTML document for export
                    const docContent = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <meta charset="UTF-8">
                            <title>Offer Letter - ${this.currentEmployee.name}</title>
                            <style>
                                body { font-family: Arial, sans-serif; line-height: 1.6; margin: 40px; }
                                h1, h2, h3 { color: #1e40af; }
                                table { border-collapse: collapse; width: 100%; margin: 20px 0; }
                                th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                                th { background-color: #f8fafc; }
                                .header { background: #1e40af; color: white; padding: 20px; text-align: center; margin-bottom: 30px; }
                            </style>
                        </head>
                        <body>
                            <div class="header">
                                <h1>Company ABC - Offer Letter</h1>
                                <p>Generated on ${new Date().toLocaleDateString()}</p>
                            </div>
                            ${htmlContent}
                        </body>
                        </html>
                    `;

                    // Create blob and download
                    const blob = new Blob([docContent], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `Offer_Letter_${this.currentEmployee.name.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.docx`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    this.showNotification('DOCX exported successfully!', 'success');

                } catch (error) {
                    console.error('DOCX export error:', error);
                    this.showNotification('Failed   to export DOCX. Please try again.', 'error');
                } finally {
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                }
            }

            async copyToClipboard() {
                if (!this.currentOfferLetter) {
                    alert('No offer letter to copy');
                    return;
                }

                try {
                    // Convert markdown to plain text
                    const plainText = this.currentOfferLetter
                        .replace(/#{1,6}\s/g, '')
                        .replace(/\*\*(.*?)\*\*/g, '$1')
                        .replace(/\*(.*?)\*/g, '$1')
                        .replace(/\[(.*?)\]\(.*?\)/g, '$1')
                        .replace(/`(.*?)`/g, '$1')
                        .replace(/---+/g, '');

                    await navigator.clipboard.writeText(plainText);
                    this.showNotification('Offer letter copied to clipboard!', 'success');
                } catch (error) {
                    console.error('Copy error:', error);
                    this.showNotification('Failed to copy to clipboard.', 'error');
                }
            }

            showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'};
                    color: white;
                    padding: 16px 24px;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                    z-index: 10000;
                    animation: slideIn 0.3s ease;
                    font-weight: 600;
                `;
                notification.textContent = message;

                document.body.appendChild(notification);

                // Remove after 3 seconds
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }

            addMessage(content, sender, searchResults = [], processingTime = 0) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                let similarityInfo = '';
                if (searchResults && searchResults.length > 0) {
                    similarityInfo = `
                        <div class="similarity-scores">
                            <strong>🔍 Vector Search Results (${processingTime}ms):</strong>
                            ${searchResults.slice(0, 5).map(result => `
                                <div class="similarity-item">
                                    <span>${result.document.title} - ${result.chunk.type}</span>
                                    <span class="similarity-score">${(result.similarity * 100).toFixed(1)}%</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                messageDiv.innerHTML = `
                    <div class="message-header">
                        <div class="message-avatar ${sender}-avatar">
                            ${sender === 'user' ? '👤' : '🤖'}
                        </div>
                        <strong>${sender === 'user' ? 'You' : 'Vector Agent'}</strong>
                        ${processingTime > 0 ? `<span style="font-size: 11px; color: #64748b;">(${processingTime}ms)</span>` : ''}
                    </div>
                    <div class="message-content">
                        ${marked.parse(content)}
                        ${similarityInfo}
                    </div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            updatePreview(offerLetter) {
                const previewContent = document.getElementById('preview-content');
                previewContent.innerHTML = marked.parse(offerLetter);
            }

            clearChat() {
                const messagesContainer = document.getElementById('messages');
                messagesContainer.innerHTML = `
                    <div class="message">
                        <div class="message-header">
                            <div class="message-avatar agent-avatar">🤖</div>
                            <strong>Vector Agent</strong>
                        </div>
                        <div class="message-content">
                            <p>Chat cleared! I'm ready to help you generate offer letters using advanced vector search and LLM reasoning.</p>
                        </div>
                    </div>
                `;
                
                // Clear preview
                document.getElementById('preview-content').innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">📋</div>
                        <h3>No Offer Letter Generated</h3>
                        <p>Use the chat interface to generate personalized offer letters</p>
                    </div>
                `;
                
                // Hide export buttons and clear current data
                this.hideExportButtons();
                this.currentOfferLetter = null;
                this.currentEmployee = null;
            }
        }

        // Initialize the application
        const app = new OfferLetterApp();
    </script>
</body>
</html>